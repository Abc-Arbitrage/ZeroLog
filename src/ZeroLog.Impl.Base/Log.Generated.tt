<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// </auto-generated>
//------------------------------------------------------------------------------
<#@ include file="LogMetadata.ttinclude" #>
using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace ZeroLog;

#nullable enable

partial class Log
{
<#
    foreach (var levelName in _logLevels)
    {
#>
    /// <summary>
    /// Indicates whether logs of <see cref="LogLevel.<#= levelName #>"/> level are enabled for this logger.
    /// </summary>
    public bool Is<#= levelName #>Enabled => LogLevel.<#= levelName #> >= _logLevel;

    /// <summary>
    /// Returns a log message builder of <see cref="LogLevel.<#= levelName #>"/> level.
    /// </summary>
    public LogMessage <#= levelName #>()
        => ForLevel(LogLevel.<#= levelName #>);

    /// <summary>
    /// Logs a message of <see cref="LogLevel.<#= levelName #>"/> level.
    /// </summary>
    /// <param name="message">The message to log.</param>
    public void <#= levelName #>(string? message)
    {
        var logMessage = ForLevel(LogLevel.<#= levelName #>);
        logMessage.InternalAppendString(message);
        logMessage.Log();
    }

    /// <summary>
    /// Logs a message of <see cref="LogLevel.<#= levelName #>"/> level with an attached exception.
    /// Note that logging an exception will allocate.
    /// </summary>
    /// <param name="message">The message to log.</param>
    /// <param name="ex">An exception to associate to the message.</param>
    public void <#= levelName #>(string? message, Exception? ex)
    {
        var logMessage = ForLevel(LogLevel.<#= levelName #>);
        logMessage.InternalAppendString(message);
        logMessage.Exception = ex;
        logMessage.Log();
    }

    /// <summary>
    /// Logs a message of <see cref="LogLevel.<#= levelName #>"/> level.
    /// </summary>
    /// <param name="message">The message to log.</param>
    public void <#= levelName #>([InterpolatedStringHandlerArgument("")] <#= levelName #>InterpolatedStringHandler message)
        => message.Message.Log();

    /// <summary>
    /// Logs a message of <see cref="LogLevel.<#= levelName #>"/> level with an attached exception.
    /// Note that logging an exception will allocate.
    /// </summary>
    /// <param name="message">The message to log.</param>
    /// <param name="ex">An exception to associate to the message.</param>
    public void <#= levelName #>([InterpolatedStringHandlerArgument("")] <#= levelName #>InterpolatedStringHandler message, Exception? ex)
    {
        message.Message.Exception = ex;
        message.Message.Log();
    }

<#
    }

    foreach (var levelName in _logLevels)
    {
#>
    /// <summary>
    /// An interpolated string handler for messages of <see cref="LogLevel.<#= levelName #>"/> level.
    /// </summary>
    [InterpolatedStringHandler]
    public readonly ref struct <#= levelName #>InterpolatedStringHandler
    {
        internal readonly LogMessage Message;

        /// <summary>
        /// Creates an interpolated string handler for messages of <see cref="LogLevel.<#= levelName #>"/> level.
        /// </summary>
        [SuppressMessage("ReSharper", "UnusedParameter.Local")]
        public <#= levelName #>InterpolatedStringHandler(int literalLength, int formattedCount, Log log, out bool isEnabled)
        {
            if (log.Is<#= levelName #>Enabled)
            {
                Message = log.InternalAcquireLogMessage(LogLevel.<#= levelName #>);
                isEnabled = true;
            }
            else
            {
                Message = LogMessage.Empty;
                isEnabled = false;
            }
        }

        /// <summary>
        /// Appends a literal string to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendLiteral(string value)
            => Message.InternalAppendString(value);

        /// <summary>
        /// Appends a value of type <c>string</c> to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendFormatted(string? value)
            => Message.InternalAppendString(value);

        /// <summary>
        /// Appends a string represented by a <c>ReadOnlySpan&lt;char&gt;</c> to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendFormatted(ReadOnlySpan<char> value)
            => Message.InternalAppendStringSpan(value);

        /// <summary>
        /// Appends an UTF-8 string represented by a <c>ReadOnlySpanReadOnlySpan&lt;byte&gt;</c> to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendFormatted(ReadOnlySpan<byte> value)
            => Message.InternalAppendUtf8StringSpan(value);

<#
        foreach (var type in _valueTypes)
        {
#>
        /// <summary>
        /// Appends a value of type <c><#= type.name #></c> to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendFormatted(<#= type.name #> value)
            => Message.InternalAppendValueType(value, ArgumentType.<#= type.argType #>);

        /// <summary>
        /// Appends a value of type <c><#= type.name #>?</c> to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendFormatted(<#= type.name #>? value)
            => Message.InternalAppendValueType(value, ArgumentType.<#= type.argType #>);

<#
            if (type.isFormattable)
            {
#>
        /// <summary>
        /// Appends a value of type <c><#= type.name #></c> to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <param name="format">The format string.</param>
        public void AppendFormatted(<#= type.name #> value, string format)
            => Message.InternalAppendValueType(value, format, ArgumentType.<#= type.argType #>);

        /// <summary>
        /// Appends a value of type <c><#= type.name #>?</c> to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <param name="format">The format string.</param>
        public void AppendFormatted(<#= type.name #>? value, string format)
            => Message.InternalAppendValueType(value, format, ArgumentType.<#= type.argType #>);

<#
            }
        }
#>
        /// <summary>
        /// Appends an enum to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendFormatted<T>(T value) where T : struct, Enum
            => Message.InternalAppendEnum(value);

        /// <summary>
        /// Appends a nullable enum to the handler.
        /// </summary>
        /// <param name="value">The value to append.</param>
        public void AppendFormatted<T>(T? value) where T : struct, Enum
            => Message.InternalAppendEnum(value);

        /// <summary>
        /// Executes an append operation on the underlying log message.
        /// </summary>
        /// <param name="operation">The operation to execute.</param>
        public void AppendFormatted<T>(LogMessage.AppendOperation<T> operation)
            => operation.AppendAction?.Invoke(Message, operation.Value);
    }

<#
    }
#>
}
