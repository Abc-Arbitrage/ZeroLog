<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// </auto-generated>
//------------------------------------------------------------------------------
<#@ include file="LogMetadata.ttinclude" #>
using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace ZeroLog;

#nullable enable

partial class Log
{
<#
    foreach (var levelName in _logLevels)
    {
#>
    public bool Is<#= levelName #>Enabled => Level.<#= levelName #> >= _logLevel;
<#
    }
#>

<#
    foreach (var levelName in _logLevels)
    {
#>
    public LogMessage <#= levelName #>()
        => ForLevel(Level.<#= levelName #>);

    public void <#= levelName #>([InterpolatedStringHandlerArgument("")] <#= levelName #>InterpolatedStringHandler message)
        => message.Message.Log();

    public void <#= levelName #>([InterpolatedStringHandlerArgument("")] <#= levelName #>InterpolatedStringHandler message, Exception? ex)
    {
        message.Message.Exception = ex;
        message.Message.Log();
    }

<#
    }

    foreach (var levelName in _logLevels)
    {
#>
    [InterpolatedStringHandler]
    public readonly ref struct <#= levelName #>InterpolatedStringHandler
    {
        internal readonly LogMessage Message;

        [SuppressMessage("ReSharper", "UnusedParameter.Local")]
        public <#= levelName #>InterpolatedStringHandler(int literalLength, int formattedCount, Log log, out bool isEnabled)
        {
            if (log.Is<#= levelName #>Enabled)
            {
                Message = log.GetLogMessage(Level.<#= levelName #>);
                isEnabled = true;
            }
            else
            {
                Message = LogMessage.Empty;
                isEnabled = false;
            }
        }

        public void AppendLiteral(string value)
            => Message.InternalAppendString(value);

        public void AppendFormatted(string? value)
            => Message.InternalAppendString(value);

<#
        foreach (var type in _valueTypes)
        {
#>
        public void AppendFormatted(<#= type.name #> value)
            => Message.InternalAppendValueType(value, ArgumentType.<#= type.argType #>);

        public void AppendFormatted(<#= type.name #>? value)
            => Message.InternalAppendValueType(value, ArgumentType.<#= type.argType #>);

<#
            if (type.isFormattable)
            {
#>
        public void AppendFormatted(<#= type.name #> value, string format)
            => Message.InternalAppendValueType(value, format, ArgumentType.<#= type.argType #>);

        public void AppendFormatted(<#= type.name #>? value, string format)
            => Message.InternalAppendValueType(value, format, ArgumentType.<#= type.argType #>);

<#
            }
        }
#>
        public void AppendFormatted<T>(T value) where T : struct, Enum
            => Message.InternalAppendEnum(value);

        public void AppendFormatted<T>(T? value) where T : struct, Enum
            => Message.InternalAppendEnum(value);

    }

<#
    }
#>
}
