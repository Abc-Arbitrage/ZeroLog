<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".cs" #>
<#
    var loggableLevelNames = new[] { "Debug", "Info", "Warn", "Error", "Fatal" };
    const int formatMaxArgCount = 8;
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System;
using JetBrains.Annotations;

namespace ZeroLog
{
    partial interface ILog
    {
<#
    foreach (var levelName in loggableLevelNames)
    {
#>
        bool Is<#= levelName #>Enabled { get; }
<#
    }
#>

<#
    foreach (var levelName in loggableLevelNames)
    {
#>
        ILogEvent <#= levelName #>();
        void <#= levelName #>(string? message);
        void <#= levelName #>(string? message, Exception? ex);
<#
        for (var argCount = 1; argCount <= formatMaxArgCount; ++argCount)
        {
#>
        <#= FormatMethodSignature(levelName, argCount) #>;
<#
        }
#>

<#
    }
#>
    }

    partial class Log
    {
<#
        foreach (var levelName in loggableLevelNames)
        {
#>
        public bool Is<#= levelName #>Enabled => Level.<#= levelName #> >= _logLevel;

        public ILogEvent <#= levelName #>()
        {
            return Is<#= levelName #>Enabled
                ? GetLogEventFor(Level.<#= levelName #>)
                : NoopLogEvent.Instance;
        }

        public void <#= levelName #>(string? message)
        {
            if (!Is<#= levelName #>Enabled)
                return;

            GetLogEventFor(Level.<#= levelName #>).Append(message).Log();
        }

        public void <#= levelName #>(string? message, Exception? ex)
        {
            if (!Is<#= levelName #>Enabled)
                return;

            var logEvent = GetLogEventFor(Level.<#= levelName #>);
            logEvent.Append(message);
            logEvent.Append(ex?.ToString());
            logEvent.Log();
        }

<#
            for (var argCount = 1; argCount <= formatMaxArgCount; ++argCount)
            {
#>
        [StringFormatMethod("format")]
        public <#= FormatMethodSignature(levelName, argCount) #>
        {
            if (!Is<#= levelName #>Enabled || format is null)
                return;

            var logEvent = GetLogEventFor(Level.<#= levelName #>);
            logEvent.AppendFormat(format);
<#
                for (var argIdx = 0; argIdx < argCount; ++argIdx)
                {
#>
            logEvent.AppendGeneric(arg<#= argIdx #>);
<#
                }
#>
            logEvent.Log();
        }

<#
            }
        }
#>
    }

    partial class NoopLogManager
    {
        partial class NoopLog
        {
<#
        foreach (var levelName in loggableLevelNames)
        {
#>
            public bool Is<#= levelName #>Enabled => false;

            public ILogEvent <#= levelName #>()
                => NoopLogEvent.Instance;

            public void <#= levelName #>(string? message)
            {
            }

            public void <#= levelName #>(string? message, Exception? ex)
            {
            }

<#
            for (var argCount = 1; argCount <= formatMaxArgCount; ++argCount)
            {
#>
            public <#= FormatMethodSignature(levelName, argCount) #>
            {
            }

<#
            }
#>
<#
        }
#>
        }
    }
}
<#

    static string FormatMethodSignature(string levelName, int argCount)
    {
        var sb = new StringBuilder();
        sb.Append("void ").Append(levelName).Append("Format<");

        for (var argIdx = 0; argIdx < argCount; ++argIdx)
        {
            if (argIdx != 0)
                sb.Append(", ");

            sb.Append("T").Append(argIdx);
        }

        sb.Append(">(string format");

        for (var argIdx = 0; argIdx < argCount; ++argIdx)
        {
            sb.Append(", T").Append(argIdx).Append(" arg").Append(argIdx);
        }

        sb.Append(")");
        return sb.ToString();
    }

#>
