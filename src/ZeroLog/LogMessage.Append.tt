<#@ template language="C#" #>
<#
    var valueTypes = new (string name, string argType, bool isFormattable)[]
    {
        ("bool", "Boolean", false),
        ("byte", "Byte", true),
        ("sbyte", "SByte", true),
        ("char", "Char", false),
        ("short", "Int16", true),
        ("ushort", "UInt16", true),
        ("int", "Int32", true),
        ("uint", "UInt32", true),
        ("long", "Int64", true),
        ("ulong", "UInt64", true),
        ("nint", "IntPtr", true),
        ("nuint", "UIntPtr", true),
        ("float", "Single", true),
        ("double", "Double", true),
        ("decimal", "Decimal", true),
        ("Guid", "Guid", true),
        ("DateTime", "DateTime", true),
        ("TimeSpan", "TimeSpan", true),
    };
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;

namespace ZeroLog;

#nullable enable

unsafe partial class LogMessage
{
<#
    foreach (var type in valueTypes)
    {
#>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public LogMessage Append(<#= type.name #> value)
    {
        InternalAppend(value);
        return this;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public LogMessage Append(<#= type.name #>? value)
    {
        InternalAppend(value);
        return this;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void InternalAppend(<#= type.name #> value)
    {
        if (_dataPointer + sizeof(ArgumentType) + sizeof(<#= type.name #>) <= _endOfBuffer)
        {
            *(ArgumentType*)_dataPointer = ArgumentType.<#= type.argType #>;
            _dataPointer += sizeof(ArgumentType);

            *(<#= type.name #>*)_dataPointer = value;
            _dataPointer += sizeof(<#= type.name #>);
        }
        else
        {
            _isTruncated = true;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void InternalAppend(<#= type.name #>? value)
    {
        if (value is not null)
            InternalAppend(value.GetValueOrDefault());
        else
            InternalAppendNull();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public LogMessage AppendKeyValue(string key, <#= type.name #> value)
    {
        if (_dataPointer + sizeof(ArgumentType) + sizeof(byte) + sizeof(ArgumentType) + sizeof(<#= type.name #>) <= _endOfBuffer && _stringIndex < _strings.Length)
        {
            *(ArgumentType*)_dataPointer = ArgumentType.KeyString;
            _dataPointer += sizeof(ArgumentType);

            _strings[_stringIndex] = key;

            *_dataPointer = _stringIndex;
            ++_stringIndex;

            *(ArgumentType*)_dataPointer = ArgumentType.<#= type.argType #>;
            _dataPointer += sizeof(ArgumentType);

            *(<#= type.name #>*)_dataPointer = value;
            _dataPointer += sizeof(<#= type.name #>);
        }
        else
        {
            _isTruncated = true;
        }

        return this;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public LogMessage AppendKeyValue(string key, <#= type.name #>? value)
    {
        if (_dataPointer + sizeof(ArgumentType) + sizeof(byte) + sizeof(ArgumentType) + sizeof(<#= type.name #>) <= _endOfBuffer && _stringIndex < _strings.Length)
        {
            *(ArgumentType*)_dataPointer = ArgumentType.KeyString;
            _dataPointer += sizeof(ArgumentType);

            _strings[_stringIndex] = key;

            *_dataPointer = _stringIndex;
            ++_stringIndex;

            if (value is not null)
            {
                *(ArgumentType*)_dataPointer = ArgumentType.<#= type.argType #>;
                _dataPointer += sizeof(ArgumentType);

                *(<#= type.name #>*)_dataPointer = value.GetValueOrDefault();
                _dataPointer += sizeof(<#= type.name #>);
            }
            else
            {
                *(ArgumentType*)_dataPointer = ArgumentType.Null;
                _dataPointer += sizeof(ArgumentType);
            }
        }
        else
        {
            _isTruncated = true;
        }

        return this;
    }

<#
        if (type.isFormattable)
        {
            #>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public LogMessage Append(<#= type.name #> value, string format)
    {
        InternalAppend(value, format);
        return this;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public LogMessage Append(<#= type.name #>? value, string format)
    {
        InternalAppend(value, format);
        return this;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void InternalAppend(<#= type.name #> value, string format)
    {
        if (_dataPointer + sizeof(ArgumentType) + sizeof(byte) + sizeof(<#= type.name #>) <= _endOfBuffer && _stringIndex < _strings.Length)
        {
            *(ArgumentType*)_dataPointer = ArgumentType.<#= type.argType #> | ArgumentType.FormatFlag;
            _dataPointer += sizeof(ArgumentType);

            _strings[_stringIndex] = format;

            *_dataPointer = _stringIndex;
            ++_dataPointer;

            ++_stringIndex;

            *(<#= type.name #>*)_dataPointer = value;
            _dataPointer += sizeof(<#= type.name #>);
        }
        else
        {
            _isTruncated = true;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void InternalAppend(<#= type.name #>? value, string format)
    {
        if (value is not null)
            InternalAppend(value.GetValueOrDefault(), format);
        else
            InternalAppendNull();
    }

<#
        }
    }
#>
}
