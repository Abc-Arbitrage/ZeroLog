<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new (string name, string argType, bool isFormattable)[]
    {
        ("bool", "Boolean", false),
        ("byte", "Byte", true),
        ("char", "Char", false),
        ("short", "Int16", true),
        ("int", "Int32", true),
        ("long", "Int64", true),
        ("float", "Single", true),
        ("double", "Double", true),
        ("decimal", "Decimal", true),
        ("Guid", "Guid", true),
        ("DateTime", "DateTime", true),
        ("TimeSpan", "TimeSpan", true),
    };
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System;
using System.Runtime.CompilerServices;
using ZeroLog.Utils;

namespace ZeroLog
{
    partial interface ILogEvent
    {
<#
    foreach (var type in types)
    {
#>
        ILogEvent Append(<#= type.name #> value);
        ILogEvent Append(<#= type.name #>? value);
<#
        if (type.isFormattable)
        {
#>
        ILogEvent Append(<#= type.name #> value, string format);
        ILogEvent Append(<#= type.name #>? value, string format);
<#
        }
    }
#>
    }

    unsafe partial class LogEvent
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AppendGeneric<T>(T arg)
        {
            // Some remarks here:
            // - The JIT knows the type of "arg" at runtime and will be able the remove useless branches for each
            //   struct specific jitted version of this method.
            // - Since a jitted version of this method will be shared for all reference types, the optimisation
            //   we just mentionned earlier can't occur. That's why we put the test against string at the top.
            // - Casting to "object" then to the desired value type will force the C# compiler to emit boxing and
            //   unboxing IL opcodes, but the JIT is smart enough to prevent the actual boxing/unboxing from happening.

            if (typeof(T) == typeof(string))
                Append((string?)(object?)arg);
<#
    foreach (var type in types)
    {
#>
            else if (typeof(T) == typeof(<#= type.name #>))
                Append((<#= type.name #>)(object)arg!);
            else if (typeof(T) == typeof(<#= type.name #>?))
                Append((<#= type.name #>?)(object?)arg);
<#
    }
#>
            else if (TypeUtil<T>.IsEnum)
                AppendEnumInternal(arg);
            else
                AppendGenericSlow(arg);
        }

<#
    foreach (var type in types)
    {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ILogEvent Append(<#= type.name #> value)
        {
            if (!PrepareAppend(sizeof(ArgumentType) + sizeof(<#= type.name #>)))
                return this;

            AppendArgumentType(ArgumentType.<#= type.argType #>);
            *(<#= type.name #>*)_dataPointer = value;
            _dataPointer += sizeof(<#= type.name #>);
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ILogEvent Append(<#= type.name #>? value)
        {
            if (!PrepareAppend(sizeof(ArgumentType) + sizeof(<#= type.name #>)))
                return this;

            if (value == null)
            {
                AppendArgumentType(ArgumentType.Null);
                return this;
            }

            AppendArgumentType(ArgumentType.<#= type.argType #>);
            *(<#= type.name #>*)_dataPointer = value.GetValueOrDefault();
            _dataPointer += sizeof(<#= type.name #>);
            return this;
        }

<#
        if (type.isFormattable)
        {
#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ILogEvent Append(<#= type.name #> value, string format)
        {
            if (!PrepareAppend(sizeof(ArgumentType) + sizeof(byte) + sizeof(<#= type.name #>)))
                return this;

            AppendArgumentTypeWithFormat(ArgumentType.<#= type.argType #>);
            AppendString(format);
            *(<#= type.name #>*)_dataPointer = value;
            _dataPointer += sizeof(<#= type.name #>);
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ILogEvent Append(<#= type.name #>? value, string format)
        {
            if (!PrepareAppend(sizeof(ArgumentType) + sizeof(byte) + sizeof(<#= type.name #>)))
                return this;

            if (value == null)
            {
                AppendArgumentType(ArgumentType.Null);
                return this;
            }

            AppendArgumentTypeWithFormat(ArgumentType.<#= type.argType #>);
            AppendString(format);
            *(<#= type.name #>*)_dataPointer = value.GetValueOrDefault();
            _dataPointer += sizeof(<#= type.name #>);
            return this;
        }

<#
        }
    }
#>
    }

    partial class NoopLogEvent
    {
<#
    foreach (var type in types)
    {
#>
        public ILogEvent Append(<#= type.name #> value) => this;
        public ILogEvent Append(<#= type.name #>? value) => this;
<#
        if (type.isFormattable)
        {
#>
        public ILogEvent Append(<#= type.name #> value, string format) => this;
        public ILogEvent Append(<#= type.name #>? value, string format) => this;
<#
        }
    }
#>
    }

    partial class ForwardingLogEvent
    {
<#
    foreach (var type in types)
    {
#>
        public ILogEvent Append(<#= type.name #> value) => this;
        public ILogEvent Append(<#= type.name #>? value) => this;
<#
        if (type.isFormattable)
        {
#>
        public ILogEvent Append(<#= type.name #> value, string format) => this;
        public ILogEvent Append(<#= type.name #>? value, string format) => this;
<#
        }
    }
#>
    }
}
